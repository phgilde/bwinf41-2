\documentclass[a4paper,10pt,ngerman]{scrartcl}
\usepackage{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8x]{inputenc}
\usepackage[a4paper,margin=2.5cm,footskip=0.5cm]{geometry}

% Die nächsten drei Felder bitte anpassen:
\newcommand{\Aufgabe}{Aufgabe 1: \LaTeX-Dokument} % Aufgabennummer und Aufgabennamen angeben
\newcommand{\TeilnahmeId}{?????}                  % Teilnahme-ID angeben
\newcommand{\Name}{Vor- und Nachname}             % Name des Bearbeiter / der Bearbeiterin dieser Aufgabe angeben

% Kopf- und Fußzeilen
\usepackage{scrlayer-scrpage, lastpage}
\setkomafont{pageheadfoot}{\large\textrm}
\lohead{\Aufgabe}
\rohead{Teilnahme-ID: \TeilnahmeId}
\cfoot*{\thepage{}/\pageref{LastPage}}

% Position des Titels
\usepackage{titling}
\setlength{\droptitle}{-1.0cm}

% Für mathematische Befehle und Symbole
\usepackage{amsmath}
\usepackage{amssymb}

% Für Bilder
\usepackage{graphicx}

% Für Algorithmen
\usepackage{algpseudocode}
\usepackage{amsthm}
\usepackage{tabularx}
\usepackage{booktabs}

% Für Quelltext
\usepackage{listings}
\usepackage{color}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\lstset{
  keywordstyle=\color{blue},commentstyle=\color{mygreen},
  stringstyle=\color{mymauve},rulecolor=\color{black},
  basicstyle=\footnotesize\ttfamily,numberstyle=\tiny\color{mygray},
  captionpos=b, % sets the caption-position to bottom
  keepspaces=true, % keeps spaces in text
  numbers=left, numbersep=5pt, showspaces=false,showstringspaces=true,
  showtabs=false, stepnumber=2, tabsize=2, title=\lstname
}
\lstdefinelanguage{JavaScript}{ % JavaScript ist als einzige Sprache noch nicht vordefiniert
  keywords={break, case, catch, continue, debugger, default, delete, do, else, finally, for, function, if, in, instanceof, new, return, switch, this, throw, try, typeof, var, void, while, with},
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]',
  morestring=[b]",
  sensitive=true
}

% Diese beiden Pakete müssen zuletzt geladen werden
%\usepackage{hyperref} % Anklickbare Links im Dokument
\usepackage{cleveref}

% Daten für die Titelseite
\title{\textbf{\Huge\Aufgabe}}
\author{\LARGE Teilnahme-ID: \LARGE \TeilnahmeId \\\\
  \LARGE Bearbeiter/-in dieser Aufgabe: \\
  \LARGE \Name\\\\}
\date{\LARGE\today}
\newtheorem{theorem}{Satz}
\newtheorem{lemma}[theorem]{Lemma}
\begin{document}

\maketitle
\tableofcontents

\vspace{0.5cm}

\textbf{Anleitung:} Trage oben in den Zeilen 8 bis 10 die Aufgabennummer, die Teilnahme-ID und die/den Bearbeiterin/Bearbeiter dieser Aufgabe mit Vor- und Nachnamen ein.
Vergiss nicht, auch den Aufgabennamen anzupassen (statt "`\LaTeX-Dokument"')!

Dann kannst du dieses Dokument mit deiner \LaTeX-Umgebung übersetzen.

Die Texte, die hier bereits stehen, geben ein paar Hinweise zur Einsendung. Du
solltest sie aber in deiner Einsendung wieder entfernen!

\section{Lösungsidee}
\subsection{Einleitung}
Es ist $\mathcal{NP}$-schwer, das weniger krumme Touren-Problem (WKT) optimal
zu lösen. Um das zu zeigen, wird eine Reduktion vom eulerschen Pfad-Problem des
Handlungsreisenden (E-PTSP) skizziert, welches bekanntermaßen
$\mathcal{NP}$-schwer ist. E-PTSP lautet folgendermaßen: Sei $P \subset
  \mathbb{R}^2$ eine endliche Menge. Dann wird eine Reihenfolge von P gesucht,
bei der die Strecke zwischen aufeinanderfolgenden Punkten minimal ist. \\
E-PTSP kann nun auf WKT reduziert werden, in dem jeder der Punkte $P$ durch
eine Struktur $S$ mit sehr kleinem $d$ ersetzt wird. Wie das Diagramm zeigt,
kann Struktur S aus beliebigen Richtungen angeflogen werden. Wenn die Struktur
sehr klein ist, verhält sie sich wie ein Punkt im E-PTSP. Die Reihenfolge, in
welcher die Strukturen optimal angeflogen werden, ist demnach auch die optimale
Reihenfolge der Punkte $P$ für E-PTSP. \\\\ Unter der Annahme $\mathcal{P} \neq
  \mathcal{NP}$ gibt es deshalb keinen Algorithmus, der WKT in polynomieller Zeit
optimal lößt. Stattdessen stelle ich einen Algorithmus vor, der eine optimale
Lösung in polynomieller Zeit annähert, sowie einen Lösungsansatz, der das
Problem in exponentieller Zeit optimal lößt.
\subsection{Annäherung}
Das Problem wird mit Hilfe des Simulated Annealing gelößt.
\begin{algorithmic}
  \Procedure{Simulated Annealing}{Startlösung $S$, Temperatur $T_0$, Abkühlkoeffizient $\alpha$, Iterationen $n$}
  \State{$S_{Beste} \gets S$}
  \State{$C_{Beste} \gets C(S)$}
  \State{$T \gets T_0$}
  \For{$i \in {1, 2, \ldots, n}$}
  \State{$S_{Neu} \gets \text{Nachbarlösung von } S$}
  \State{$C_{Neu} \gets C(S_{Neu}) $}
  \If{$C_{Neu} < C_{Beste}$}
  \State{$C_{Beste} \gets C_{Neu} $}
  \State{$S_{Beste} \gets S_{Neu} $}
  \EndIf
  \State{$r \gets \text{Zufallszahl aus }[0,1]$}
  \If{$r < \exp(\frac{C(S)-C_{Neu}}{T})$}
  \State{$S \gets S_{Neu}$}
  \EndIf
  \State{$T \gets \alpha T$}
  \EndFor

  \Return{$S_{Beste}$}
  \EndProcedure
\end{algorithmic}
Gültige Lösungen sind hier alle möglichen Permutationen von $N$ Landeplätzen. Die Beschränkung, dass eine
Lösung keine Spitzen Winkel beinhalten darf, wird über die Kostenfunktion $C(S)$ kodiert. Die Kostenfunktion
setzt sich zusammen aus der Länge des von $S$ gebildeten Pfades und einer Gebühr $g \in \mathbb{R}$ für jeden spitzen Winkel. $g$
ist eine obere Schranke der Länge eines Pfades, wodurch für jeden Pfad $S'$ mit weniger spitzen Winkeln als $S$
gilt $C(S) > C(S')$. Diese obere Schranke erschließt sich aus der Überlegung, dass eine mögliche Lösung mindestens $N-1$ Kanten haben muss.
Dieser Pfad kann höchstens die Kosten der teuersten $N-1$ Kanten haben. \\
Um Nachbarn einer Lösung zu finden, habe ich die für das klassische TSP bekannten Mutationsoperatoren \textbf{Insert}, \textbf{Displace}, \textbf{Reverse-Displace}
//TODO quote mutationsoperatoren
und einen eigenen, auf dem 3-Opt-Verfahren basierenden Mutationsoperator, den ich \textbf{3-Opt} nenne, verwendet. Die Operatoren basieren auf der
Darstellung eines Pfades als Permutation von $(1, 2, \ldots, N)$. In dieser Darstellung gibt das $k$-te Element der Permutation
an, welcher Landeplatz als $k$-tes besucht wird.
\begin{description}
  \item[Insert] wählt einen zufälligen Landeplatz der Permutation aus und setzt ihn an eine zufällige neue Stelle.
  \item[Displace] wählt ein zufälliges Segment der Permutation aus und setzt es an eine zufällige neue Stelle.
  \item[Reverse-Displace] wählt ein zufälliges Segment der Permutation aus und setzt es in umgekehrter Reihenfolge an eine zufällige neue Stelle.
\end{description}
\subsection{Optimale Lösung}
Zur optimalen Lösung von WKT wird dieses als Integer-Programming-Problem
formuliert. Integer Programming ist $\mathcal{NP}$-schwer, weshalb dafür nur
Algorithmen exponentieller Laufzeit bekannt sind. \\ Sei also $I$ eine Instanz
von $WKT$ mit den Punkten $P \subset \mathbb{R}^2$. Die Landeplätze sind
$L=\{1,2,\ldots,|P|\}$ Die Variable $x_{i,j} \in \{0, 1\}$ it $i, j \in L; i<j$
kodiert, ob die Route die Punkte $P_i$ und $P_j$ direkt nacheinander anfliegt,
wobei nicht festgelegt ist, welcher zuerst angeflogen wird. Man sagt auch: Die
Lösung hat eine Kante zwischen $P_i$ und $P_j$. Die Variable $y_i \in \{0,1\}$
mit $i\in L$ kodiert, ob der Pfad bei $P_i$ anfängt oder endet. Das
Integer-Programming-Problem lautet dann:
\begin{align}
  \text{minimiere} \sum^{|P|}_{i=1} \sum^{|P|}_{j=1, j>i} c_{i,j} x_{i,j} \text{ mit}                                                                                                       \\
  \sum_{j=i+1}^{|P|} x_{i,j} + \sum_{k=1}^{i-1} x_{k,i} + y_i   & = 2          &  & \text{Für alle } i \in \{1,2,\ldots,|P|\}                                                               \\
  \sum_{i=1}^{|P|} y_i                                          & = 2                                                                                                                       \\
  x_{\min(i,j), \max(i,j)} + x_{\min(j,k), \max(j,k)}           & \leq 1       &  & \text{Für alle } i,j,k \in L; i \neq j; j \neq k; i \neq k; P_i, P_j, P_k \text{ bilden spitzen Winkel} \\
  \sum_{i\in Q} \sum_{j \in Q; j != i} x_{\min(i,j), \max(i,j)} & \leq |Q| - 1 &  & \text{Für alle } Q \subset L ; |Q| \geq 2                                                               \\
\end{align}
Der zu minimierende Term (1) bedeutet, dass die Gesamtlänge des Pfades möglichst kurz sein soll. (2) sorgt dafür, dass auf jeder Landeplatz
zwei Landeplätze hat, die direkt vor und nach ihm im Pfad angeflogen werden, oder genau einen, wenn der Landeplatz an einem Ende des Pfades liegt.
(3) sorgt dafür, dass es nur 2 solcher Endlandeplätze gibt. (4) verhindert, dass es im Pfad spitze Winkel gibt. Wenn zwei Kanten einen Spitzen
Winkel bilden, dann darf maximal eine dieser Kanten in der Lösung sein. (5) sorgt dafür, dass die Lösung nur ein Pfad ist, und nicht ein Pfad und
Kreise durch die restlichen Knoten. Weil (5) exponentiell viele Bedingungen beinhaltet, muss es als Lazy Constraint formuliert werden. Wenn es
eine potentielle Lösung gibt, wird ein Algorithmus auf diese Lösung angewendet, der Kreise in ihr sucht, und aus den Kreisen die entsprechenden Bedingungen
formuliert. Auf diese Weise kann diese Bedingung auch Schnittebenen aus Relaxationen formulieren, wobei in der Relaxationslösung Kreise gesucht werden. \\
Dieses Integer-Programming-Problem kann mit dem Branch-and-Cut-Algorithmus gelößt werden. Als Startlösung verwende ich dabei das Ergebnis des beschriebenen
Annäherungsalgorithmus.
\section{Umsetzung}
Hier wird kurz erläutert, wie die Lösungsidee im Programm tatsächlich umgesetzt
wurde. Hier können auch Implementierungsdetails erwähnt werden.

\section{Beispiele}
Genügend Beispiele einbinden! Die Beispiele von der BwInf-Webseite sollten hier
diskutiert werden, aber auch eigene Beispiele sind sehr gut – besonders wenn
sie Spezialfälle abdecken. Aber bitte nicht 30 Seiten Programmausgabe hier
einfügen!

\section{Quellcode}
\end{document}